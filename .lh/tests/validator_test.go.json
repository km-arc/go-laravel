{
    "sourceFile": "tests/validator_test.go",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1772220531308,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1772220531308,
            "name": "Commit-0",
            "content": "package validation_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/km-arc/go-laravel/http/validation\"\n)\n\n// ── helpers ──────────────────────────────────────────────────────────────────\n\n// pass asserts the validator passes for the given data/rules.\nfunc pass(t *testing.T, label string, data map[string]string, rules validation.Rules) {\n\tt.Helper()\n\tt.Run(label, func(t *testing.T) {\n\t\tv := validation.Make(data, rules)\n\t\tif v.Fails() {\n\t\t\tt.Errorf(\"expected PASS, got FAIL — errors: %+v\", v.Errors().Bag)\n\t\t}\n\t})\n}\n\n// fail asserts the validator fails with an error on the given field.\nfunc fail(t *testing.T, label, field string, data map[string]string, rules validation.Rules) {\n\tt.Helper()\n\tt.Run(label, func(t *testing.T) {\n\t\tv := validation.Make(data, rules)\n\t\tif v.Passes() {\n\t\t\tt.Errorf(\"expected FAIL on field %q, but validator PASSED\", field)\n\t\t}\n\t\tif v.Errors().First(field) == \"\" {\n\t\t\tt.Errorf(\"expected error on field %q, but none found. Errors: %+v\", field, v.Errors().Bag)\n\t\t}\n\t})\n}\n\n// ── required ─────────────────────────────────────────────────────────────────\n\nfunc TestValidation_Required(t *testing.T) {\n\tr := validation.Rules{\"name\": \"required\"}\n\n\tpass(t, \"non-empty value\", map[string]string{\"name\": \"Alice\"}, r)\n\tfail(t, \"empty string\", \"name\", map[string]string{\"name\": \"\"}, r)\n\tfail(t, \"whitespace only\", \"name\", map[string]string{\"name\": \"   \"}, r)\n\tfail(t, \"missing key\", map[string]string{}, r) // must be fail\n}\n\nfunc TestValidation_Required_MessageFormat(t *testing.T) {\n\tv := validation.Make(map[string]string{\"name\": \"\"}, validation.Rules{\"name\": \"required\"})\n\t_ = v.Fails()\n\tmsg := v.Errors().First(\"name\")\n\texpected := \"The name field is required.\"\n\tif msg != expected {\n\t\tt.Errorf(\"message: got %q want %q\", msg, expected)\n\t}\n}\n\n// ── email ─────────────────────────────────────────────────────────────────────\n\nfunc TestValidation_Email(t *testing.T) {\n\tr := validation.Rules{\"email\": \"email\"}\n\n\tpass(t, \"valid email\", map[string]string{\"email\": \"user@example.com\"}, r)\n\tpass(t, \"valid email with subdomain\", map[string]string{\"email\": \"user@mail.example.co.uk\"}, r)\n\tfail(t, \"no @ sign\", \"email\", map[string]string{\"email\": \"notanemail\"}, r)\n\tfail(t, \"no domain\", \"email\", map[string]string{\"email\": \"user@\"}, r)\n}\n\n// ── min / max / size / between ───────────────────────────────────────────────\n\nfunc TestValidation_Min(t *testing.T) {\n\tr := validation.Rules{\"name\": \"min:3\"}\n\n\tpass(t, \"exactly 3\", map[string]string{\"name\": \"abc\"}, r)\n\tpass(t, \"more than 3\", map[string]string{\"name\": \"abcde\"}, r)\n\tfail(t, \"less than 3\", \"name\", map[string]string{\"name\": \"ab\"}, r)\n\tfail(t, \"empty\", \"name\", map[string]string{\"name\": \"\"}, r)\n}\n\nfunc TestValidation_Max(t *testing.T) {\n\tr := validation.Rules{\"bio\": \"max:5\"}\n\n\tpass(t, \"exactly 5\", map[string]string{\"bio\": \"hello\"}, r)\n\tpass(t, \"less than 5\", map[string]string{\"bio\": \"hi\"}, r)\n\tfail(t, \"more than 5\", \"bio\", map[string]string{\"bio\": \"toolong\"}, r)\n}\n\nfunc TestValidation_Size(t *testing.T) {\n\tr := validation.Rules{\"code\": \"size:4\"}\n\n\tpass(t, \"exactly 4\", map[string]string{\"code\": \"1234\"}, r)\n\tfail(t, \"too short\", \"code\", map[string]string{\"code\": \"123\"}, r)\n\tfail(t, \"too long\", \"code\", map[string]string{\"code\": \"12345\"}, r)\n}\n\nfunc TestValidation_Between(t *testing.T) {\n\tr := validation.Rules{\"pin\": \"between:4,6\"}\n\n\tpass(t, \"min boundary\", map[string]string{\"pin\": \"1234\"}, r)\n\tpass(t, \"max boundary\", map[string]string{\"pin\": \"123456\"}, r)\n\tpass(t, \"middle\", map[string]string{\"pin\": \"12345\"}, r)\n\tfail(t, \"too short\", \"pin\", map[string]string{\"pin\": \"123\"}, r)\n\tfail(t, \"too long\", \"pin\", map[string]string{\"pin\": \"1234567\"}, r)\n}\n\n// ── Unicode character counting ────────────────────────────────────────────────\n\nfunc TestValidation_Min_Unicode(t *testing.T) {\n\t// \"日本語\" = 3 runes, min:3 should pass\n\tpass(t, \"unicode rune count\", map[string]string{\"name\": \"日本語\"}, validation.Rules{\"name\": \"min:3\"})\n\tfail(t, \"unicode rune count too short\", \"name\", map[string]string{\"name\": \"日本\"}, validation.Rules{\"name\": \"min:3\"})\n}\n\n// ── numeric / integer / boolean ───────────────────────────────────────────────\n\nfunc TestValidation_Numeric(t *testing.T) {\n\tr := validation.Rules{\"amount\": \"numeric\"}\n\n\tpass(t, \"integer\", map[string]string{\"amount\": \"42\"}, r)\n\tpass(t, \"float\", map[string]string{\"amount\": \"3.14\"}, r)\n\tpass(t, \"negative\", map[string]string{\"amount\": \"-5.5\"}, r)\n\tfail(t, \"string\", \"amount\", map[string]string{\"amount\": \"abc\"}, r)\n\tfail(t, \"mixed\", \"amount\", map[string]string{\"amount\": \"12abc\"}, r)\n}\n\nfunc TestValidation_Integer(t *testing.T) {\n\tr := validation.Rules{\"count\": \"integer\"}\n\n\tpass(t, \"positive int\", map[string]string{\"count\": \"10\"}, r)\n\tpass(t, \"negative int\", map[string]string{\"count\": \"-3\"}, r)\n\tfail(t, \"float\", \"count\", map[string]string{\"count\": \"3.14\"}, r)\n\tfail(t, \"string\", \"count\", map[string]string{\"count\": \"abc\"}, r)\n}\n\nfunc TestValidation_Boolean(t *testing.T) {\n\tr := validation.Rules{\"active\": \"boolean\"}\n\n\tfor _, v := range []string{\"true\", \"false\", \"1\", \"0\", \"yes\", \"no\", \"True\", \"False\"} {\n\t\tpass(t, \"boolean \"+v, map[string]string{\"active\": v}, r)\n\t}\n\tfail(t, \"invalid bool\", \"active\", map[string]string{\"active\": \"maybe\"}, r)\n}\n\n// ── in / not_in ───────────────────────────────────────────────────────────────\n\nfunc TestValidation_In(t *testing.T) {\n\tr := validation.Rules{\"role\": \"in:admin,editor,viewer\"}\n\n\tpass(t, \"admin\", map[string]string{\"role\": \"admin\"}, r)\n\tpass(t, \"editor\", map[string]string{\"role\": \"editor\"}, r)\n\tfail(t, \"superuser not in list\", \"role\", map[string]string{\"role\": \"superuser\"}, r)\n\tfail(t, \"empty not in list\", \"role\", map[string]string{\"role\": \"\"}, r)\n}\n\nfunc TestValidation_NotIn(t *testing.T) {\n\tr := validation.Rules{\"status\": \"not_in:banned,suspended\"}\n\n\tpass(t, \"active\", map[string]string{\"status\": \"active\"}, r)\n\tfail(t, \"banned\", \"status\", map[string]string{\"status\": \"banned\"}, r)\n\tfail(t, \"suspended\", \"status\", map[string]string{\"status\": \"suspended\"}, r)\n}\n\n// ── confirmed ─────────────────────────────────────────────────────────────────\n\nfunc TestValidation_Confirmed(t *testing.T) {\n\tr := validation.Rules{\"password\": \"confirmed\"}\n\n\tpass(t, \"matching\", map[string]string{\n\t\t\"password\":              \"secret\",\n\t\t\"password_confirmation\": \"secret\",\n\t}, r)\n\tfail(t, \"not matching\", \"password\", map[string]string{\n\t\t\"password\":              \"secret\",\n\t\t\"password_confirmation\": \"wrong\",\n\t}, r)\n\tfail(t, \"missing confirmation\", \"password\", map[string]string{\n\t\t\"password\": \"secret\",\n\t}, r)\n}\n\n// ── same / different ─────────────────────────────────────────────────────────\n\nfunc TestValidation_Same(t *testing.T) {\n\tr := validation.Rules{\"confirm_email\": \"same:email\"}\n\n\tpass(t, \"same value\", map[string]string{\n\t\t\"email\":         \"a@b.com\",\n\t\t\"confirm_email\": \"a@b.com\",\n\t}, r)\n\tfail(t, \"different value\", \"confirm_email\", map[string]string{\n\t\t\"email\":         \"a@b.com\",\n\t\t\"confirm_email\": \"c@d.com\",\n\t}, r)\n}\n\nfunc TestValidation_Different(t *testing.T) {\n\tr := validation.Rules{\"new_password\": \"different:old_password\"}\n\n\tpass(t, \"different values\", map[string]string{\n\t\t\"old_password\": \"old\",\n\t\t\"new_password\": \"new\",\n\t}, r)\n\tfail(t, \"same value\", \"new_password\", map[string]string{\n\t\t\"old_password\": \"same\",\n\t\t\"new_password\": \"same\",\n\t}, r)\n}\n\n// ── alpha / alpha_num / alpha_dash ────────────────────────────────────────────\n\nfunc TestValidation_Alpha(t *testing.T) {\n\tr := validation.Rules{\"name\": \"alpha\"}\n\n\tpass(t, \"letters only\", map[string]string{\"name\": \"HelloWorld\"}, r)\n\tfail(t, \"with numbers\", \"name\", map[string]string{\"name\": \"hello123\"}, r)\n\tfail(t, \"with spaces\", \"name\", map[string]string{\"name\": \"hello world\"}, r)\n}\n\nfunc TestValidation_AlphaNum(t *testing.T) {\n\tr := validation.Rules{\"slug\": \"alpha_num\"}\n\n\tpass(t, \"letters and numbers\", map[string]string{\"slug\": \"user123\"}, r)\n\tfail(t, \"with dash\", \"slug\", map[string]string{\"slug\": \"user-123\"}, r)\n\tfail(t, \"with space\", \"slug\", map[string]string{\"slug\": \"user 123\"}, r)\n}\n\nfunc TestValidation_AlphaDash(t *testing.T) {\n\tr := validation.Rules{\"slug\": \"alpha_dash\"}\n\n\tpass(t, \"letters-numbers_underscore\", map[string]string{\"slug\": \"user_name-123\"}, r)\n\tfail(t, \"with space\", \"slug\", map[string]string{\"slug\": \"user name\"}, r)\n\tfail(t, \"with dot\", \"slug\", map[string]string{\"slug\": \"user.name\"}, r)\n}\n\n// ── url ───────────────────────────────────────────────────────────────────────\n\nfunc TestValidation_URL(t *testing.T) {\n\tr := validation.Rules{\"website\": \"url\"}\n\n\tpass(t, \"http\", map[string]string{\"website\": \"http://example.com\"}, r)\n\tpass(t, \"https\", map[string]string{\"website\": \"https://example.com/path?q=1\"}, r)\n\tfail(t, \"no protocol\", \"website\", map[string]string{\"website\": \"example.com\"}, r)\n\tfail(t, \"ftp protocol\", \"website\", map[string]string{\"website\": \"ftp://example.com\"}, r)\n}\n\n// ── regex ─────────────────────────────────────────────────────────────────────\n\nfunc TestValidation_Regex(t *testing.T) {\n\tr := validation.Rules{\"zip\": `regex:^\\d{5}$`}\n\n\tpass(t, \"5 digits\", map[string]string{\"zip\": \"12345\"}, r)\n\tfail(t, \"4 digits\", \"zip\", map[string]string{\"zip\": \"1234\"}, r)\n\tfail(t, \"letters\", \"zip\", map[string]string{\"zip\": \"abcde\"}, r)\n}\n\n// ── gt / gte / lt / lte ───────────────────────────────────────────────────────\n\nfunc TestValidation_GT(t *testing.T) {\n\tr := validation.Rules{\"age\": \"gt:18\"}\n\n\tpass(t, \"19 > 18\", map[string]string{\"age\": \"19\"}, r)\n\tfail(t, \"18 not > 18\", \"age\", map[string]string{\"age\": \"18\"}, r)\n\tfail(t, \"17 not > 18\", \"age\", map[string]string{\"age\": \"17\"}, r)\n}\n\nfunc TestValidation_GTE(t *testing.T) {\n\tr := validation.Rules{\"age\": \"gte:18\"}\n\n\tpass(t, \"18 >= 18\", map[string]string{\"age\": \"18\"}, r)\n\tpass(t, \"19 >= 18\", map[string]string{\"age\": \"19\"}, r)\n\tfail(t, \"17 not >= 18\", \"age\", map[string]string{\"age\": \"17\"}, r)\n}\n\nfunc TestValidation_LT(t *testing.T) {\n\tr := validation.Rules{\"score\": \"lt:100\"}\n\n\tpass(t, \"99 < 100\", map[string]string{\"score\": \"99\"}, r)\n\tfail(t, \"100 not < 100\", \"score\", map[string]string{\"score\": \"100\"}, r)\n}\n\nfunc TestValidation_LTE(t *testing.T) {\n\tr := validation.Rules{\"score\": \"lte:100\"}\n\n\tpass(t, \"100 <= 100\", map[string]string{\"score\": \"100\"}, r)\n\tpass(t, \"99 <= 100\", map[string]string{\"score\": \"99\"}, r)\n\tfail(t, \"101 not <= 100\", \"score\", map[string]string{\"score\": \"101\"}, r)\n}\n\n// ── nullable / sometimes ──────────────────────────────────────────────────────\n\nfunc TestValidation_Nullable(t *testing.T) {\n\t// nullable allows empty values through without error\n\tr := validation.Rules{\"bio\": \"nullable|min:10\"}\n\t// empty value — nullable stops further processing\n\tpass(t, \"empty with nullable\", map[string]string{\"bio\": \"\"}, r)\n}\n\nfunc TestValidation_Sometimes(t *testing.T) {\n\tr := validation.Rules{\"nickname\": \"sometimes|min:3\"}\n\t// field absent — should not produce errors\n\tpass(t, \"absent field with sometimes\", map[string]string{}, r)\n\t// field present and valid\n\tpass(t, \"present and valid\", map[string]string{\"nickname\": \"coolname\"}, r)\n}\n\n// ── Chained / multiple rules ──────────────────────────────────────────────────\n\nfunc TestValidation_Chained(t *testing.T) {\n\trules := validation.Rules{\n\t\t\"email\":    \"required|email\",\n\t\t\"password\": \"required|min:8|confirmed\",\n\t\t\"age\":      \"required|integer|gte:18\",\n\t}\n\n\tpass(t, \"all valid\", map[string]string{\n\t\t\"email\":                 \"user@example.com\",\n\t\t\"password\":              \"secret123\",\n\t\t\"password_confirmation\": \"secret123\",\n\t\t\"age\":                   \"25\",\n\t}, rules)\n\n\tv := validation.Make(map[string]string{\n\t\t\"email\":    \"not-an-email\",\n\t\t\"password\": \"short\",\n\t\t\"age\":      \"16\",\n\t}, rules)\n\n\tif v.Passes() {\n\t\tt.Error(\"expected validation to fail\")\n\t}\n\n\terrs := v.Errors()\n\tif errs.First(\"email\") == \"\" {\n\t\tt.Error(\"expected error on email\")\n\t}\n\tif errs.First(\"password\") == \"\" {\n\t\tt.Error(\"expected error on password\")\n\t}\n\tif errs.First(\"age\") == \"\" {\n\t\tt.Error(\"expected error on age\")\n\t}\n}\n\n// ── Errors bag ────────────────────────────────────────────────────────────────\n\nfunc TestErrors_Has(t *testing.T) {\n\tv := validation.Make(map[string]string{\"name\": \"\"}, validation.Rules{\"name\": \"required\"})\n\tif !v.Fails() {\n\t\tt.Fatal(\"expected fails\")\n\t}\n\tif !v.Errors().Has() {\n\t\tt.Error(\"Has() should be true when there are errors\")\n\t}\n}\n\nfunc TestErrors_First(t *testing.T) {\n\tv := validation.Make(\n\t\tmap[string]string{\"email\": \"bad\"},\n\t\tvalidation.Rules{\"email\": \"required|email\"},\n\t)\n\t_ = v.Fails()\n\tif v.Errors().First(\"email\") == \"\" {\n\t\tt.Error(\"First('email') should return error message\")\n\t}\n\tif v.Errors().First(\"nonexistent\") != \"\" {\n\t\tt.Error(\"First('nonexistent') should return empty string\")\n\t}\n}\n\nfunc TestErrors_Passes(t *testing.T) {\n\tv := validation.Make(\n\t\tmap[string]string{\"name\": \"Alice\"},\n\t\tvalidation.Rules{\"name\": \"required|min:2\"},\n\t)\n\tif !v.Passes() {\n\t\tt.Errorf(\"expected Passes(), errors: %+v\", v.Errors().Bag)\n\t}\n}\n\n// ── JSON output shape ─────────────────────────────────────────────────────────\n\nfunc TestErrors_JSONShape(t *testing.T) {\n\t// The Errors struct must marshal to {\"errors\": {\"field\": [\"msg1\"]}}\n\t// This is tested by checking the Bag field tag\n\tv := validation.Make(\n\t\tmap[string]string{\"email\": \"\"},\n\t\tvalidation.Rules{\"email\": \"required\"},\n\t)\n\t_ = v.Fails()\n\n\terrs := v.Errors()\n\tif errs.Bag == nil {\n\t\tt.Fatal(\"Bag should not be nil after failure\")\n\t}\n\tmsgs, ok := errs.Bag[\"email\"]\n\tif !ok {\n\t\tt.Fatal(\"expected 'email' key in Bag\")\n\t}\n\tif len(msgs) == 0 {\n\t\tt.Error(\"expected at least one message for email\")\n\t}\n}\n"
        }
    ]
}