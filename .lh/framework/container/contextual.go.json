{
    "sourceFile": "framework/container/contextual.go",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1772226739245,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1772227362727,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,449 +1,40 @@\n package container\n \n-import (\n-\t\"fmt\"\n-\t\"reflect\"\n-\t\"sync\"\n-)\n-\n-// ── Binding types ─────────────────────────────────────────────────────────────\n-\n-// Factory is a function that builds a concrete value from the container.\n-type Factory func(c *Container) any\n-\n-// binding holds a registered factory and whether it is a singleton.\n-type binding struct {\n-\tfactory   Factory\n-\tsingleton bool\n-}\n-\n-// extender wraps an already-resolved instance with decorator logic.\n-type extender func(instance any, c *Container) any\n-\n-// ── Container ─────────────────────────────────────────────────────────────────\n-\n-// Container is the IoC container — mirrors Laravel's Illuminate\\Container\\Container.\n+// ContextualBuilder implements the fluent contextual binding API.\n //\n-// It supports:\n-//   - Bind / Singleton / Instance / Alias\n-//   - Make / Resolve (generic)\n-//   - Tags (group multiple abstractions under one tag)\n-//   - Extend (decorate / wrap resolved instances)\n-//   - Contextual binding (when A needs B, give it C)\n-//   - Rebound callbacks\n-//   - Resolved event callbacks\n-type Container struct {\n-\tmu sync.RWMutex\n-\n-\t// abstract → binding\n-\tbindings map[string]*binding\n-\n-\t// abstract → resolved singleton instance\n-\tinstances map[string]any\n-\n-\t// alias → abstract (canonical key)\n-\taliases map[string]string\n-\n-\t// abstract → extender funcs\n-\textenders map[string][]extender\n-\n-\t// tag → []abstract\n-\ttags map[string][]string\n-\n-\t// contextual: when[concrete][abstract] = factory\n-\tcontextual map[string]map[string]Factory\n-\n-\t// rebound callbacks: abstract → []func(any)\n-\treboundCallbacks map[string][]func(any)\n-\n-\t// resolved callbacks: []func(abstract, instance)\n-\tafterResolving []func(string, any)\n-\n-\t// stack of abstracts currently being resolved (for contextual lookup)\n-\tbuildStack []string\n-}\n-\n-// New creates an empty container.\n-func New() *Container {\n-\tc := &Container{\n-\t\tbindings:         make(map[string]*binding),\n-\t\tinstances:        make(map[string]any),\n-\t\taliases:          make(map[string]string),\n-\t\textenders:        make(map[string][]extender),\n-\t\ttags:             make(map[string][]string),\n-\t\tcontextual:       make(map[string]map[string]Factory),\n-\t\treboundCallbacks: make(map[string][]func(any)),\n-\t}\n-\t// Bind the container to itself — like Laravel's $app->instance()\n-\tc.Instance(\"container\", c)\n-\treturn c\n-}\n-\n-// ── Registration ──────────────────────────────────────────────────────────────\n-\n-// Bind registers a transient (new instance each Make) factory.\n-//\n-//\t// Laravel: $app->bind(UserRepository::class, fn($app) => new EloquentUserRepository($app))\n-//\tc.Bind(\"UserRepository\", func(c *container.Container) any {\n-//\t    return &EloquentUserRepository{DB: Resolve[*gorm.DB](c, \"db\")}\n-//\t})\n-func (c *Container) Bind(abstract string, factory Factory) {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\tc.bind(abstract, factory, false)\n-}\n-\n-// Singleton registers a factory whose result is cached after first resolution.\n-//\n-//\t// Laravel: $app->singleton(Cache::class, fn($app) => new RedisCache($app))\n-//\tc.Singleton(\"cache\", func(c *container.Container) any {\n-//\t    return cache.NewRedisCache(Resolve[*config.Config](c, \"config\"))\n-//\t})\n-func (c *Container) Singleton(abstract string, factory Factory) {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\tc.bind(abstract, factory, true)\n-}\n-\n-// Instance registers a pre-built value as a singleton.\n-//\n-//\t// Laravel: $app->instance(Config::class, $config)\n-//\tc.Instance(\"config\", myConfig)\n-func (c *Container) Instance(abstract string, instance any) {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\tdelete(c.bindings, c.canonical(abstract))\n-\tkey := c.canonical(abstract)\n-\tc.instances[key] = instance\n-\tc.fireRebound(abstract, instance)\n-}\n-\n-// bind is the internal registration helper (must hold mu.Lock).\n-func (c *Container) bind(abstract string, factory Factory, singleton bool) {\n-\tkey := c.canonical(abstract)\n-\n-\t// Drop existing singleton instance so it's rebuilt with the new factory\n-\twasBound := c.instances[key] != nil\n-\tdelete(c.instances, key)\n-\n-\tc.bindings[key] = &binding{factory: factory, singleton: singleton}\n-\n-\tif wasBound {\n-\t\tc.mu.Unlock()\n-\t\tc.fireRebound(abstract, c.make(abstract))\n-\t\tc.mu.Lock()\n-\t}\n-}\n-\n-// Alias registers an alternative name for an abstract.\n-//\n-//\t// Laravel: $app->alias(Cache::class, 'cache')\n-//\tc.Alias(\"cache\", \"cacheManager\")\n-func (c *Container) Alias(abstract, alias string) {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\tif abstract == alias {\n-\t\tpanic(fmt.Sprintf(\"container: [%s] is aliased to itself\", abstract))\n-\t}\n-\tc.aliases[alias] = c.canonical(abstract)\n-}\n-\n-// ── Contextual Binding ────────────────────────────────────────────────────────\n-\n-// When starts a contextual binding chain.\n-//\n-//\t// Laravel: $app->when(PhotoController::class)->needs(Filesystem::class)->give(fn() => new S3)\n+//\t// Laravel: $app->when(PhotoController::class)->needs(Filesystem::class)->give(...)\n //\tc.When(\"PhotoController\").Needs(\"Filesystem\").Give(func(c *container.Container) any {\n //\t    return filesystem.NewS3(...)\n //\t})\n-func (c *Container) When(concrete string) *ContextualBuilder {\n-\treturn &ContextualBuilder{container: c, concrete: concrete}\n+type ContextualBuilder struct {\n+\tcontainer *Container\n+\tconcrete  string\n+\tneeds     string\n }\n \n-// getContextual returns the contextual factory for (concrete, abstract), or nil.\n-func (c *Container) getContextual(concrete, abstract string) Factory {\n-\tc.mu.RLock()\n-\tdefer c.mu.RUnlock()\n-\tif m, ok := c.contextual[concrete]; ok {\n-\t\tif f, ok := m[abstract]; ok {\n-\t\t\treturn f\n-\t\t}\n-\t}\n-\treturn nil\n+// Needs specifies which abstract the concrete type depends on.\n+func (b *ContextualBuilder) Needs(abstract string) *ContextualBuilder {\n+\tb.needs = abstract\n+\treturn b\n }\n \n-// ── Extend ────────────────────────────────────────────────────────────────────\n+// Give provides the factory that should be used when the concrete type\n+// resolves the specified abstract.\n+func (b *ContextualBuilder) Give(factory Factory) {\n+\tb.container.mu.Lock()\n+\tdefer b.container.mu.Unlock()\n \n-// Extend decorates the resolved instance of an abstract.\n-//\n-//\t// Laravel: $app->extend(Logger::class, fn($logger, $app) => new TimestampLogger($logger))\n-//\tc.Extend(\"logger\", func(instance any, c *container.Container) any {\n-//\t    return logging.NewTimestampWrapper(instance.(*Logger))\n-//\t})\n-func (c *Container) Extend(abstract string, fn extender) {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\tkey := c.canonical(abstract)\n-\tc.extenders[key] = append(c.extenders[key], fn)\n-\n-\t// If already resolved as singleton, re-apply extenders and refire rebound\n-\tif inst, ok := c.instances[key]; ok {\n-\t\textended := c.applyExtenders(key, inst)\n-\t\tc.instances[key] = extended\n-\t\tc.mu.Unlock()\n-\t\tc.fireRebound(abstract, extended)\n-\t\tc.mu.Lock()\n+\tif _, ok := b.container.contextual[b.concrete]; !ok {\n+\t\tb.container.contextual[b.concrete] = make(map[string]Factory)\n \t}\n+\tb.container.contextual[b.concrete][b.needs] = factory\n }\n \n-// ── Tags ──────────────────────────────────────────────────────────────────────\n-\n-// Tag associates multiple abstracts under a named group.\n+// GiveValue is a shorthand for Give when the value is a simple scalar or\n+// pre-built instance (no factory logic needed).\n //\n-//\t// Laravel: $app->tag([CpuReport::class, MemoryReport::class], 'reports')\n-//\tc.Tag([]string{\"CpuReport\", \"MemoryReport\"}, \"reports\")\n-func (c *Container) Tag(abstracts []string, tag string) {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\tc.tags[tag] = append(c.tags[tag], abstracts...)\n-}\n-\n-// Tagged resolves all abstracts registered under a tag.\n-//\n-//\t// Laravel: $app->tagged('reports')\n-//\treports := c.Tagged(\"reports\")  // []any\n-func (c *Container) Tagged(tag string) []any {\n-\tc.mu.RLock()\n-\tabstracts := c.tags[tag]\n-\tc.mu.RUnlock()\n-\n-\tresult := make([]any, 0, len(abstracts))\n-\tfor _, abs := range abstracts {\n-\t\tresult = append(result, c.make(abs))\n-\t}\n-\treturn result\n-}\n-\n-// ── Resolution ────────────────────────────────────────────────────────────────\n-\n-// Make resolves an abstract from the container.\n-//\n-//\t// Laravel: $app->make(UserRepository::class)\n-//\trepo := c.Make(\"UserRepository\")\n-func (c *Container) Make(abstract string) any {\n-\treturn c.make(abstract)\n-}\n-\n-// make is the internal resolver (no outer lock — individual ops lock as needed).\n-func (c *Container) make(abstract string) any {\n-\tkey := c.canonical(abstract)\n-\n-\t// Check singleton instance cache\n-\tc.mu.RLock()\n-\tif inst, ok := c.instances[key]; ok {\n-\t\tc.mu.RUnlock()\n-\t\treturn inst\n-\t}\n-\tc.mu.RUnlock()\n-\n-\t// Check contextual binding (look at current build stack top)\n-\tif len(c.buildStack) > 0 {\n-\t\tcaller := c.buildStack[len(c.buildStack)-1]\n-\t\tif f := c.getContextual(caller, abstract); f != nil {\n-\t\t\treturn c.runFactory(key, f, false)\n-\t\t}\n-\t}\n-\n-\t// Look up binding\n-\tc.mu.RLock()\n-\tb, ok := c.bindings[key]\n-\tc.mu.RUnlock()\n-\n-\tif !ok {\n-\t\t// No binding — try to return nil gracefully\n-\t\tpanic(fmt.Sprintf(\"container: no binding registered for [%s]\", abstract))\n-\t}\n-\n-\treturn c.runFactory(key, b.factory, b.singleton)\n-}\n-\n-// runFactory executes a factory, optionally caching the result.\n-func (c *Container) runFactory(key string, f Factory, singleton bool) any {\n-\tc.buildStack = append(c.buildStack, key)\n-\n-\tinstance := f(c)\n-\n-\tc.buildStack = c.buildStack[:len(c.buildStack)-1]\n-\n-\t// Apply extenders\n-\tc.mu.RLock()\n-\texts := c.extenders[key]\n-\tc.mu.RUnlock()\n-\tif len(exts) > 0 {\n-\t\tinstance = c.applyExtenders(key, instance)\n-\t}\n-\n-\tif singleton {\n-\t\tc.mu.Lock()\n-\t\tc.instances[key] = instance\n-\t\tc.mu.Unlock()\n-\t}\n-\n-\tc.fireAfterResolving(key, instance)\n-\treturn instance\n-}\n-\n-func (c *Container) applyExtenders(key string, instance any) any {\n-\tfor _, ext := range c.extenders[key] {\n-\t\tinstance = ext(instance, c)\n-\t}\n-\treturn instance\n-}\n-\n-// ── Helpers ───────────────────────────────────────────────────────────────────\n-\n-// Bound returns true if an abstract has been registered.\n-//\n-//\t// Laravel: $app->bound(UserRepository::class)\n-func (c *Container) Bound(abstract string) bool {\n-\tc.mu.RLock()\n-\tdefer c.mu.RUnlock()\n-\tkey := c.canonical(abstract)\n-\t_, hasBinding := c.bindings[key]\n-\t_, hasInstance := c.instances[key]\n-\treturn hasBinding || hasInstance\n-}\n-\n-// Resolved returns true if the abstract has been resolved at least once.\n-//\n-//\t// Laravel: $app->resolved(Cache::class)\n-func (c *Container) Resolved(abstract string) bool {\n-\tc.mu.RLock()\n-\tdefer c.mu.RUnlock()\n-\tkey := c.canonical(abstract)\n-\t_, ok := c.instances[key]\n-\treturn ok\n-}\n-\n-// Forget removes all registrations for an abstract (binding + instance).\n-//\n-//\t// Laravel: $app->forgetInstance(Cache::class)\n-func (c *Container) Forget(abstract string) {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\tkey := c.canonical(abstract)\n-\tdelete(c.bindings, key)\n-\tdelete(c.instances, key)\n-}\n-\n-// Flush resets the entire container.\n-func (c *Container) Flush() {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\tc.bindings = make(map[string]*binding)\n-\tc.instances = make(map[string]any)\n-\tc.aliases = make(map[string]string)\n-\tc.extenders = make(map[string][]extender)\n-\tc.tags = make(map[string][]string)\n-\tc.contextual = make(map[string]map[string]Factory)\n-}\n-\n-// Bindings returns a copy of all registered abstract keys (for debugging).\n-func (c *Container) Bindings() []string {\n-\tc.mu.RLock()\n-\tdefer c.mu.RUnlock()\n-\tout := make([]string, 0, len(c.bindings)+len(c.instances))\n-\tfor k := range c.bindings {\n-\t\tout = append(out, k)\n-\t}\n-\tfor k := range c.instances {\n-\t\tif _, already := c.bindings[k]; !already {\n-\t\t\tout = append(out, k)\n-\t\t}\n-\t}\n-\treturn out\n-}\n-\n-// canonical resolves an alias to its canonical key.\n-func (c *Container) canonical(abstract string) string {\n-\tif target, ok := c.aliases[abstract]; ok {\n-\t\treturn target\n-\t}\n-\treturn abstract\n-}\n-\n-// ── Callbacks ─────────────────────────────────────────────────────────────────\n-\n-// Rebinding registers a callback to be called whenever an abstract is re-bound.\n-//\n-//\t// Laravel: $app->rebinding(UserRepository::class, fn($app, $repo) => ...)\n-func (c *Container) Rebinding(abstract string, cb func(any)) {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\tc.reboundCallbacks[abstract] = append(c.reboundCallbacks[abstract], cb)\n-}\n-\n-// AfterResolving registers a callback fired after any abstract is resolved.\n-//\n-//\t// Laravel: $app->afterResolving(fn($object, $app) => ...)\n-func (c *Container) AfterResolving(cb func(abstract string, instance any)) {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\tc.afterResolving = append(c.afterResolving, cb)\n-}\n-\n-func (c *Container) fireRebound(abstract string, instance any) {\n-\tc.mu.RLock()\n-\tcbs := c.reboundCallbacks[abstract]\n-\tc.mu.RUnlock()\n-\tfor _, cb := range cbs {\n-\t\tcb(instance)\n-\t}\n-}\n-\n-func (c *Container) fireAfterResolving(abstract string, instance any) {\n-\tc.mu.RLock()\n-\tcbs := c.afterResolving\n-\tc.mu.RUnlock()\n-\tfor _, cb := range cbs {\n-\t\tcb(abstract, instance)\n-\t}\n-}\n-\n-// ── Reflect helpers ───────────────────────────────────────────────────────────\n-\n-// TypeKey returns the package-qualified type name of v, useful as a stable\n-// abstract key when working with interfaces.\n-//\n-//\tkey := container.TypeKey((*UserRepository)(nil))  // \"main.UserRepository\"\n-//\tc.Singleton(key, factory)\n-//\trepo := container.Resolve[UserRepository](c, key)\n-func TypeKey(v any) string {\n-\tt := reflect.TypeOf(v)\n-\tif t.Kind() == reflect.Ptr {\n-\t\tt = t.Elem()\n-\t}\n-\treturn t.PkgPath() + \".\" + t.Name()\n-}\n-\n-// ── Generics helper ───────────────────────────────────────────────────────────\n-\n-// Resolve is a generic helper that calls Make and type-asserts the result.\n-//\n-//\t// Instead of: db := c.Make(\"db\").(*gorm.DB)\n-//\t// Write:      db := container.Resolve[*gorm.DB](c, \"db\")\n-func Resolve[T any](c *Container, abstract string) T {\n-\tinstance := c.Make(abstract)\n-\ttyped, ok := instance.(T)\n-\tif !ok {\n-\t\tpanic(fmt.Sprintf(\"container: Resolve[%T]: [%s] resolved to %T\", *new(T), abstract, instance))\n-\t}\n-\treturn typed\n-}\n-\n-// MustResolve is like Resolve but returns (T, bool) without panicking.\n-func MustResolve[T any](c *Container, abstract string) (T, bool) {\n-\tinstance := c.Make(abstract)\n-\ttyped, ok := instance.(T)\n-\treturn typed, ok\n+//\t// Laravel: ->give('/tmp/photos')\n+//\tc.When(\"PhotoController\").Needs(\"storagePath\").GiveValue(\"/tmp/photos\")\n+func (b *ContextualBuilder) GiveValue(value any) {\n+\tb.Give(func(_ *Container) any { return value })\n }\n\\ No newline at end of file\n"
                }
            ],
            "date": 1772226739245,
            "name": "Commit-0",
            "content": "package container\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"sync\"\n)\n\n// ── Binding types ─────────────────────────────────────────────────────────────\n\n// Factory is a function that builds a concrete value from the container.\ntype Factory func(c *Container) any\n\n// binding holds a registered factory and whether it is a singleton.\ntype binding struct {\n\tfactory   Factory\n\tsingleton bool\n}\n\n// extender wraps an already-resolved instance with decorator logic.\ntype extender func(instance any, c *Container) any\n\n// ── Container ─────────────────────────────────────────────────────────────────\n\n// Container is the IoC container — mirrors Laravel's Illuminate\\Container\\Container.\n//\n// It supports:\n//   - Bind / Singleton / Instance / Alias\n//   - Make / Resolve (generic)\n//   - Tags (group multiple abstractions under one tag)\n//   - Extend (decorate / wrap resolved instances)\n//   - Contextual binding (when A needs B, give it C)\n//   - Rebound callbacks\n//   - Resolved event callbacks\ntype Container struct {\n\tmu sync.RWMutex\n\n\t// abstract → binding\n\tbindings map[string]*binding\n\n\t// abstract → resolved singleton instance\n\tinstances map[string]any\n\n\t// alias → abstract (canonical key)\n\taliases map[string]string\n\n\t// abstract → extender funcs\n\textenders map[string][]extender\n\n\t// tag → []abstract\n\ttags map[string][]string\n\n\t// contextual: when[concrete][abstract] = factory\n\tcontextual map[string]map[string]Factory\n\n\t// rebound callbacks: abstract → []func(any)\n\treboundCallbacks map[string][]func(any)\n\n\t// resolved callbacks: []func(abstract, instance)\n\tafterResolving []func(string, any)\n\n\t// stack of abstracts currently being resolved (for contextual lookup)\n\tbuildStack []string\n}\n\n// New creates an empty container.\nfunc New() *Container {\n\tc := &Container{\n\t\tbindings:         make(map[string]*binding),\n\t\tinstances:        make(map[string]any),\n\t\taliases:          make(map[string]string),\n\t\textenders:        make(map[string][]extender),\n\t\ttags:             make(map[string][]string),\n\t\tcontextual:       make(map[string]map[string]Factory),\n\t\treboundCallbacks: make(map[string][]func(any)),\n\t}\n\t// Bind the container to itself — like Laravel's $app->instance()\n\tc.Instance(\"container\", c)\n\treturn c\n}\n\n// ── Registration ──────────────────────────────────────────────────────────────\n\n// Bind registers a transient (new instance each Make) factory.\n//\n//\t// Laravel: $app->bind(UserRepository::class, fn($app) => new EloquentUserRepository($app))\n//\tc.Bind(\"UserRepository\", func(c *container.Container) any {\n//\t    return &EloquentUserRepository{DB: Resolve[*gorm.DB](c, \"db\")}\n//\t})\nfunc (c *Container) Bind(abstract string, factory Factory) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.bind(abstract, factory, false)\n}\n\n// Singleton registers a factory whose result is cached after first resolution.\n//\n//\t// Laravel: $app->singleton(Cache::class, fn($app) => new RedisCache($app))\n//\tc.Singleton(\"cache\", func(c *container.Container) any {\n//\t    return cache.NewRedisCache(Resolve[*config.Config](c, \"config\"))\n//\t})\nfunc (c *Container) Singleton(abstract string, factory Factory) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.bind(abstract, factory, true)\n}\n\n// Instance registers a pre-built value as a singleton.\n//\n//\t// Laravel: $app->instance(Config::class, $config)\n//\tc.Instance(\"config\", myConfig)\nfunc (c *Container) Instance(abstract string, instance any) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tdelete(c.bindings, c.canonical(abstract))\n\tkey := c.canonical(abstract)\n\tc.instances[key] = instance\n\tc.fireRebound(abstract, instance)\n}\n\n// bind is the internal registration helper (must hold mu.Lock).\nfunc (c *Container) bind(abstract string, factory Factory, singleton bool) {\n\tkey := c.canonical(abstract)\n\n\t// Drop existing singleton instance so it's rebuilt with the new factory\n\twasBound := c.instances[key] != nil\n\tdelete(c.instances, key)\n\n\tc.bindings[key] = &binding{factory: factory, singleton: singleton}\n\n\tif wasBound {\n\t\tc.mu.Unlock()\n\t\tc.fireRebound(abstract, c.make(abstract))\n\t\tc.mu.Lock()\n\t}\n}\n\n// Alias registers an alternative name for an abstract.\n//\n//\t// Laravel: $app->alias(Cache::class, 'cache')\n//\tc.Alias(\"cache\", \"cacheManager\")\nfunc (c *Container) Alias(abstract, alias string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif abstract == alias {\n\t\tpanic(fmt.Sprintf(\"container: [%s] is aliased to itself\", abstract))\n\t}\n\tc.aliases[alias] = c.canonical(abstract)\n}\n\n// ── Contextual Binding ────────────────────────────────────────────────────────\n\n// When starts a contextual binding chain.\n//\n//\t// Laravel: $app->when(PhotoController::class)->needs(Filesystem::class)->give(fn() => new S3)\n//\tc.When(\"PhotoController\").Needs(\"Filesystem\").Give(func(c *container.Container) any {\n//\t    return filesystem.NewS3(...)\n//\t})\nfunc (c *Container) When(concrete string) *ContextualBuilder {\n\treturn &ContextualBuilder{container: c, concrete: concrete}\n}\n\n// getContextual returns the contextual factory for (concrete, abstract), or nil.\nfunc (c *Container) getContextual(concrete, abstract string) Factory {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tif m, ok := c.contextual[concrete]; ok {\n\t\tif f, ok := m[abstract]; ok {\n\t\t\treturn f\n\t\t}\n\t}\n\treturn nil\n}\n\n// ── Extend ────────────────────────────────────────────────────────────────────\n\n// Extend decorates the resolved instance of an abstract.\n//\n//\t// Laravel: $app->extend(Logger::class, fn($logger, $app) => new TimestampLogger($logger))\n//\tc.Extend(\"logger\", func(instance any, c *container.Container) any {\n//\t    return logging.NewTimestampWrapper(instance.(*Logger))\n//\t})\nfunc (c *Container) Extend(abstract string, fn extender) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tkey := c.canonical(abstract)\n\tc.extenders[key] = append(c.extenders[key], fn)\n\n\t// If already resolved as singleton, re-apply extenders and refire rebound\n\tif inst, ok := c.instances[key]; ok {\n\t\textended := c.applyExtenders(key, inst)\n\t\tc.instances[key] = extended\n\t\tc.mu.Unlock()\n\t\tc.fireRebound(abstract, extended)\n\t\tc.mu.Lock()\n\t}\n}\n\n// ── Tags ──────────────────────────────────────────────────────────────────────\n\n// Tag associates multiple abstracts under a named group.\n//\n//\t// Laravel: $app->tag([CpuReport::class, MemoryReport::class], 'reports')\n//\tc.Tag([]string{\"CpuReport\", \"MemoryReport\"}, \"reports\")\nfunc (c *Container) Tag(abstracts []string, tag string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.tags[tag] = append(c.tags[tag], abstracts...)\n}\n\n// Tagged resolves all abstracts registered under a tag.\n//\n//\t// Laravel: $app->tagged('reports')\n//\treports := c.Tagged(\"reports\")  // []any\nfunc (c *Container) Tagged(tag string) []any {\n\tc.mu.RLock()\n\tabstracts := c.tags[tag]\n\tc.mu.RUnlock()\n\n\tresult := make([]any, 0, len(abstracts))\n\tfor _, abs := range abstracts {\n\t\tresult = append(result, c.make(abs))\n\t}\n\treturn result\n}\n\n// ── Resolution ────────────────────────────────────────────────────────────────\n\n// Make resolves an abstract from the container.\n//\n//\t// Laravel: $app->make(UserRepository::class)\n//\trepo := c.Make(\"UserRepository\")\nfunc (c *Container) Make(abstract string) any {\n\treturn c.make(abstract)\n}\n\n// make is the internal resolver (no outer lock — individual ops lock as needed).\nfunc (c *Container) make(abstract string) any {\n\tkey := c.canonical(abstract)\n\n\t// Check singleton instance cache\n\tc.mu.RLock()\n\tif inst, ok := c.instances[key]; ok {\n\t\tc.mu.RUnlock()\n\t\treturn inst\n\t}\n\tc.mu.RUnlock()\n\n\t// Check contextual binding (look at current build stack top)\n\tif len(c.buildStack) > 0 {\n\t\tcaller := c.buildStack[len(c.buildStack)-1]\n\t\tif f := c.getContextual(caller, abstract); f != nil {\n\t\t\treturn c.runFactory(key, f, false)\n\t\t}\n\t}\n\n\t// Look up binding\n\tc.mu.RLock()\n\tb, ok := c.bindings[key]\n\tc.mu.RUnlock()\n\n\tif !ok {\n\t\t// No binding — try to return nil gracefully\n\t\tpanic(fmt.Sprintf(\"container: no binding registered for [%s]\", abstract))\n\t}\n\n\treturn c.runFactory(key, b.factory, b.singleton)\n}\n\n// runFactory executes a factory, optionally caching the result.\nfunc (c *Container) runFactory(key string, f Factory, singleton bool) any {\n\tc.buildStack = append(c.buildStack, key)\n\n\tinstance := f(c)\n\n\tc.buildStack = c.buildStack[:len(c.buildStack)-1]\n\n\t// Apply extenders\n\tc.mu.RLock()\n\texts := c.extenders[key]\n\tc.mu.RUnlock()\n\tif len(exts) > 0 {\n\t\tinstance = c.applyExtenders(key, instance)\n\t}\n\n\tif singleton {\n\t\tc.mu.Lock()\n\t\tc.instances[key] = instance\n\t\tc.mu.Unlock()\n\t}\n\n\tc.fireAfterResolving(key, instance)\n\treturn instance\n}\n\nfunc (c *Container) applyExtenders(key string, instance any) any {\n\tfor _, ext := range c.extenders[key] {\n\t\tinstance = ext(instance, c)\n\t}\n\treturn instance\n}\n\n// ── Helpers ───────────────────────────────────────────────────────────────────\n\n// Bound returns true if an abstract has been registered.\n//\n//\t// Laravel: $app->bound(UserRepository::class)\nfunc (c *Container) Bound(abstract string) bool {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tkey := c.canonical(abstract)\n\t_, hasBinding := c.bindings[key]\n\t_, hasInstance := c.instances[key]\n\treturn hasBinding || hasInstance\n}\n\n// Resolved returns true if the abstract has been resolved at least once.\n//\n//\t// Laravel: $app->resolved(Cache::class)\nfunc (c *Container) Resolved(abstract string) bool {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tkey := c.canonical(abstract)\n\t_, ok := c.instances[key]\n\treturn ok\n}\n\n// Forget removes all registrations for an abstract (binding + instance).\n//\n//\t// Laravel: $app->forgetInstance(Cache::class)\nfunc (c *Container) Forget(abstract string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tkey := c.canonical(abstract)\n\tdelete(c.bindings, key)\n\tdelete(c.instances, key)\n}\n\n// Flush resets the entire container.\nfunc (c *Container) Flush() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.bindings = make(map[string]*binding)\n\tc.instances = make(map[string]any)\n\tc.aliases = make(map[string]string)\n\tc.extenders = make(map[string][]extender)\n\tc.tags = make(map[string][]string)\n\tc.contextual = make(map[string]map[string]Factory)\n}\n\n// Bindings returns a copy of all registered abstract keys (for debugging).\nfunc (c *Container) Bindings() []string {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tout := make([]string, 0, len(c.bindings)+len(c.instances))\n\tfor k := range c.bindings {\n\t\tout = append(out, k)\n\t}\n\tfor k := range c.instances {\n\t\tif _, already := c.bindings[k]; !already {\n\t\t\tout = append(out, k)\n\t\t}\n\t}\n\treturn out\n}\n\n// canonical resolves an alias to its canonical key.\nfunc (c *Container) canonical(abstract string) string {\n\tif target, ok := c.aliases[abstract]; ok {\n\t\treturn target\n\t}\n\treturn abstract\n}\n\n// ── Callbacks ─────────────────────────────────────────────────────────────────\n\n// Rebinding registers a callback to be called whenever an abstract is re-bound.\n//\n//\t// Laravel: $app->rebinding(UserRepository::class, fn($app, $repo) => ...)\nfunc (c *Container) Rebinding(abstract string, cb func(any)) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.reboundCallbacks[abstract] = append(c.reboundCallbacks[abstract], cb)\n}\n\n// AfterResolving registers a callback fired after any abstract is resolved.\n//\n//\t// Laravel: $app->afterResolving(fn($object, $app) => ...)\nfunc (c *Container) AfterResolving(cb func(abstract string, instance any)) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.afterResolving = append(c.afterResolving, cb)\n}\n\nfunc (c *Container) fireRebound(abstract string, instance any) {\n\tc.mu.RLock()\n\tcbs := c.reboundCallbacks[abstract]\n\tc.mu.RUnlock()\n\tfor _, cb := range cbs {\n\t\tcb(instance)\n\t}\n}\n\nfunc (c *Container) fireAfterResolving(abstract string, instance any) {\n\tc.mu.RLock()\n\tcbs := c.afterResolving\n\tc.mu.RUnlock()\n\tfor _, cb := range cbs {\n\t\tcb(abstract, instance)\n\t}\n}\n\n// ── Reflect helpers ───────────────────────────────────────────────────────────\n\n// TypeKey returns the package-qualified type name of v, useful as a stable\n// abstract key when working with interfaces.\n//\n//\tkey := container.TypeKey((*UserRepository)(nil))  // \"main.UserRepository\"\n//\tc.Singleton(key, factory)\n//\trepo := container.Resolve[UserRepository](c, key)\nfunc TypeKey(v any) string {\n\tt := reflect.TypeOf(v)\n\tif t.Kind() == reflect.Ptr {\n\t\tt = t.Elem()\n\t}\n\treturn t.PkgPath() + \".\" + t.Name()\n}\n\n// ── Generics helper ───────────────────────────────────────────────────────────\n\n// Resolve is a generic helper that calls Make and type-asserts the result.\n//\n//\t// Instead of: db := c.Make(\"db\").(*gorm.DB)\n//\t// Write:      db := container.Resolve[*gorm.DB](c, \"db\")\nfunc Resolve[T any](c *Container, abstract string) T {\n\tinstance := c.Make(abstract)\n\ttyped, ok := instance.(T)\n\tif !ok {\n\t\tpanic(fmt.Sprintf(\"container: Resolve[%T]: [%s] resolved to %T\", *new(T), abstract, instance))\n\t}\n\treturn typed\n}\n\n// MustResolve is like Resolve but returns (T, bool) without panicking.\nfunc MustResolve[T any](c *Container, abstract string) (T, bool) {\n\tinstance := c.Make(abstract)\n\ttyped, ok := instance.(T)\n\treturn typed, ok\n}"
        }
    ]
}