{
    "sourceFile": "framework/container/ioc-container.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1772228366260,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1772228366260,
            "name": "Commit-0",
            "content": "# IoC Container & Service Providers\n\n> Full documentation for `github.com/km-arc/go-laravel/framework/container`\n>\n> Mirrors [Laravel's Service Container](https://laravel.com/docs/container) and\n> [Service Providers](https://laravel.com/docs/providers) as closely as Go allows.\n\n---\n\n## Table of Contents\n\n1. [Introduction](#introduction)\n2. [Basic Bindings](#basic-bindings)\n3. [Resolving](#resolving)\n4. [Singletons](#singletons)\n5. [Instances](#instances)\n6. [Aliases](#aliases)\n7. [Contextual Binding](#contextual-binding)\n8. [Tags](#tags)\n9. [Extending Bindings](#extending-bindings)\n10. [Callbacks & Events](#callbacks--events)\n11. [Service Providers](#service-providers)\n12. [Deferred Providers](#deferred-providers)\n13. [Wiring into Application](#wiring-into-application)\n14. [Laravel → Go Cheatsheet](#laravel--go-cheatsheet)\n\n---\n\n## Introduction\n\nThe IoC container is a tool for managing class dependencies and performing\ndependency injection. In Laravel you write:\n\n```php\n// Laravel\n$app->singleton(UserRepository::class, fn($app) => new EloquentUserRepository($app));\n$repo = $app->make(UserRepository::class);\n```\n\nIn Go, because there is no runtime constructor reflection, factories are\nexplicit closures — but the API is otherwise identical:\n\n```go\n// Go-Laravel\nc.Singleton(\"UserRepository\", func(c *container.Container) any {\n    return &EloquentUserRepository{DB: container.Resolve[*gorm.DB](c, \"db\")}\n})\nrepo := container.Resolve[*EloquentUserRepository](c, \"UserRepository\")\n```\n\n---\n\n## Basic Bindings\n\n### Bind (transient)\n\nA new instance is created on every `Make()` call.\n\n```go\n// Laravel: $app->bind(Transistor::class, fn($app) => new Transistor($app->make(PodcastParser::class)))\nc.Bind(\"Transistor\", func(c *container.Container) any {\n    parser := container.Resolve[*PodcastParser](c, \"PodcastParser\")\n    return &Transistor{Parser: parser}\n})\n```\n\n### Bind If Not Already Bound\n\n```go\n// Laravel: $app->bindIf(Transistor::class, fn($app) => new Transistor)\nif !c.Bound(\"Transistor\") {\n    c.Bind(\"Transistor\", func(c *container.Container) any {\n        return &Transistor{}\n    })\n}\n```\n\n---\n\n## Resolving\n\n### Make\n\n```go\n// Laravel: $app->make(Transistor::class)\ntransistor := c.Make(\"Transistor\")\n```\n\n### Resolve with generics (preferred)\n\nAvoids type assertions:\n\n```go\n// Instead of: repo := c.Make(\"repo\").(*UserRepository)\n// Write:\nrepo := container.Resolve[*UserRepository](c, \"repo\")\n\n// Safe version — returns (T, bool) without panic\nrepo, ok := container.MustResolve[*UserRepository](c, \"repo\")\n```\n\n---\n\n## Singletons\n\nThe factory is called once; subsequent `Make()` calls return the cached instance.\n\n```go\n// Laravel: $app->singleton(Transistor::class, fn($app) => new Transistor)\nc.Singleton(\"cache\", func(c *container.Container) any {\n    cfg := container.Resolve[*config.Config](c, \"config\")\n    return cache.NewRedis(cfg.Cache.Host)\n})\n```\n\n### Singleton If\n\n```go\n// Laravel: $app->singletonIf(Transistor::class, fn($app) => new Transistor)\nif !c.Bound(\"cache\") {\n    c.Singleton(\"cache\", factory)\n}\n```\n\n---\n\n## Instances\n\nRegister a pre-built object as a singleton.\n\n```go\n// Laravel: $app->instance(Config::class, $config)\ncfg := config.Load()\nc.Instance(\"config\", cfg)\n```\n\n---\n\n## Aliases\n\nRegister alternative names for an abstract.\n\n```go\n// Laravel: $app->alias(Cache::class, 'cache')\nc.Alias(\"cache\", \"cacheManager\")\n\n// Both resolve to the same binding:\nc.Make(\"cache\")        // ✅\nc.Make(\"cacheManager\") // ✅\n```\n\n---\n\n## Contextual Binding\n\nGive different implementations to different consumers.\n\n```go\n// Laravel:\n// $app->when(PhotoController::class)\n//     ->needs(Filesystem::class)\n//     ->give(fn() => new S3Filesystem);\n//\n// $app->when(VideoController::class)\n//     ->needs(Filesystem::class)\n//     ->give(fn() => new LocalFilesystem);\n\nc.When(\"PhotoController\").\n    Needs(\"Filesystem\").\n    Give(func(c *container.Container) any {\n        return filesystem.NewS3(container.Resolve[*config.Config](c, \"config\"))\n    })\n\nc.When(\"VideoController\").\n    Needs(\"Filesystem\").\n    Give(func(c *container.Container) any {\n        return filesystem.NewLocal(\"/var/videos\")\n    })\n```\n\n### GiveValue — inject a scalar\n\n```go\n// Laravel: ->give('/tmp/photos')\nc.When(\"ReportAggregator\").\n    Needs(\"storagePath\").\n    GiveValue(\"/tmp/reports\")\n```\n\n---\n\n## Tags\n\nGroup related bindings under a tag and resolve them all at once.\n\n```go\n// Laravel:\n// $app->tag([CpuReport::class, MemoryReport::class], 'reports');\n// $reports = $app->tagged('reports');\n\nc.Tag([]string{\"CpuReport\", \"MemReport\", \"DiskReport\"}, \"reports\")\n\n// Resolve all at once\nfor _, report := range c.Tagged(\"reports\") {\n    report.(Reporter).Generate()\n}\n```\n\n---\n\n## Extending Bindings\n\nDecorate / wrap an already-resolved service.\n\n```go\n// Laravel:\n// $app->extend(Service::class, fn($service, $app) => new DecoratedService($service));\n\nc.Extend(\"logger\", func(instance any, c *container.Container) any {\n    inner := instance.(*Logger)\n    return &TimestampLogger{Inner: inner}\n})\n```\n\n`Extend` can be chained — each extender receives the output of the previous one.\n\n---\n\n## Callbacks & Events\n\n### AfterResolving\n\nCalled every time any abstract is resolved from the container.\n\n```go\n// Laravel: $app->afterResolving(fn($obj, $app) => ...)\nc.AfterResolving(func(abstract string, instance any) {\n    log.Printf(\"resolved: %s\", abstract)\n})\n```\n\n### Rebinding\n\nCalled when an abstract is re-bound (useful for updating dependent singletons).\n\n```go\n// Laravel: $app->rebinding(UserRepository::class, fn($app, $repo) => ...)\nc.Rebinding(\"db\", func(newDB any) {\n    // Update any service that holds a reference to \"db\"\n    container.Resolve[*UserRepo](c, \"userRepo\").SetDB(newDB.(*gorm.DB))\n})\n```\n\n---\n\n## Service Providers\n\nService Providers are the central place to bootstrap your application services.\nThey have two lifecycle methods: `Register` and `Boot`.\n\n```go\n// Laravel:\n// class AppServiceProvider extends ServiceProvider {\n//     public function register(): void { ... }\n//     public function boot(): void     { ... }\n// }\n\ntype AppServiceProvider struct {\n    container.BaseProvider // provides no-op Boot, Provides, IsDeferred\n}\n\nfunc (p *AppServiceProvider) Register(app *container.Container) {\n    // ✅ ONLY bind things here — do NOT resolve other bindings\n    app.Singleton(\"mailer\", func(c *container.Container) any {\n        cfg := container.Resolve[*config.Config](c, \"config\")\n        return mail.NewSMTP(cfg.Mail)\n    })\n}\n\nfunc (p *AppServiceProvider) Boot(app *container.Container) {\n    // ✅ Safe to resolve and use any binding here\n    // All providers have been registered before Boot() is called\n    mailer := container.Resolve[*mail.SMTPMailer](app, \"mailer\")\n    mailer.SetFromName(container.Resolve[*config.Config](app, \"config\").App.Name)\n}\n```\n\n### Register the provider\n\n```go\n// Laravel: // bootstrap/app.php — Application::configure()->withProviders([...])\napplication := app.New()\napplication.Register(&AppServiceProvider{})\napplication.Register(&DatabaseServiceProvider{})\napplication.Boot()\napplication.Run()\n```\n\n---\n\n## Deferred Providers\n\nMark a provider as deferred so it is only loaded when one of its abstracts\nis first resolved. Good for heavy services (DB, queues, search).\n\n```go\n// Laravel:\n// class HeavyServiceProvider extends ServiceProvider {\n//     protected $defer = true;\n//     public function provides(): array { return [HeavyService::class]; }\n//     public function register(): void  { $this->app->singleton(HeavyService::class, ...); }\n// }\n\ntype HeavyServiceProvider struct {\n    container.BaseProvider\n}\n\nfunc (p *HeavyServiceProvider) IsDeferred() bool   { return true }\nfunc (p *HeavyServiceProvider) Provides() []string { return []string{\"heavy\"} }\n\nfunc (p *HeavyServiceProvider) Register(app *container.Container) {\n    // Only called on first app.Make(\"heavy\")\n    app.Singleton(\"heavy\", func(c *container.Container) any {\n        return heavySetup() // expensive initialization\n    })\n}\n```\n\n---\n\n## Wiring into Application\n\nThe `app.Application` embeds the container and provider registry, so you use\nthe same API from your bootstrap file:\n\n```go\napplication := app.New()  // loads .env, registers Config/Router/View providers\n\n// Register your providers\napplication.Register(&DatabaseServiceProvider{})\napplication.Register(&AuthServiceProvider{})\napplication.Register(&EventServiceProvider{})\n\n// Define routes\nr := application.Router()\nr.Get(\"/\", homeHandler)\n\n// Boot all providers, start server\napplication.Run()\n```\n\nResolve anything from the container at any point:\n\n```go\n// In a controller or middleware:\ndb     := container.Resolve[*gorm.DB](application.Container, \"db\")\nmailer := container.Resolve[*mail.Mailer](application.Container, \"mailer\")\nlogger := container.Resolve[*Logger](application.Container, \"logger\")\n```\n\n---\n\n## Laravel → Go Cheatsheet\n\n| Laravel | Go-Laravel |\n|---------|-----------|\n| `$app->bind(Foo::class, fn($app) => new Foo)` | `c.Bind(\"Foo\", func(c *container.Container) any { return &Foo{} })` |\n| `$app->singleton(Foo::class, fn($app) => new Foo)` | `c.Singleton(\"Foo\", func(c *container.Container) any { return &Foo{} })` |\n| `$app->instance(Foo::class, $foo)` | `c.Instance(\"Foo\", foo)` |\n| `$app->make(Foo::class)` | `c.Make(\"Foo\")` |\n| `app(Foo::class)` | `container.Resolve[*Foo](c, \"Foo\")` |\n| `$app->bound(Foo::class)` | `c.Bound(\"Foo\")` |\n| `$app->resolved(Foo::class)` | `c.Resolved(\"Foo\")` |\n| `$app->alias(Foo::class, 'foo')` | `c.Alias(\"Foo\", \"foo\")` |\n| `$app->tag([A::class, B::class], 'tag')` | `c.Tag([]string{\"A\", \"B\"}, \"tag\")` |\n| `$app->tagged('tag')` | `c.Tagged(\"tag\")` |\n| `$app->extend(Foo::class, fn($foo,$app) => ...)` | `c.Extend(\"Foo\", func(i any, c *container.Container) any { ... })` |\n| `$app->when(A::class)->needs(B::class)->give(...)` | `c.When(\"A\").Needs(\"B\").Give(...)` |\n| `$app->when(A::class)->needs(B::class)->give('/path')` | `c.When(\"A\").Needs(\"B\").GiveValue(\"/path\")` |\n| `$app->afterResolving(fn($obj,$app) => ...)` | `c.AfterResolving(func(abs string, inst any) { ... })` |\n| `$app->rebinding(Foo::class, fn($app,$foo) => ...)` | `c.Rebinding(\"Foo\", func(inst any) { ... })` |\n| `$app->forgetInstance(Foo::class)` | `c.Forget(\"Foo\")` |\n| `$app->flush()` | `c.Flush()` |\n| `ServiceProvider::register()` | `func (p *MyProvider) Register(app *container.Container)` |\n| `ServiceProvider::boot()` | `func (p *MyProvider) Boot(app *container.Container)` |\n| `protected $defer = true` | `func (p *MyProvider) IsDeferred() bool { return true }` |\n| `public function provides()` | `func (p *MyProvider) Provides() []string { return []string{\"foo\"} }` |\n| `$app->register(new MyProvider($app))` | `application.Register(&MyProvider{})` |\n| `$app->boot()` | `application.Boot()` |\n| `$app->booted()` | `application.Providers.Booted()` |\n| `$app->environment()` | `application.Environment()` |\n| `$app->isLocal()` | `application.IsLocal()` |\n| `$app->isProduction()` | `application.IsProduction()` |\n| `app()->version()` | `application.Version()` |\n\n---\n\n## Why No Auto-Wiring?\n\nLaravel uses PHP's reflection API to introspect constructor parameters and\nresolve them automatically. Go's `reflect` package can read struct fields and\nmethod signatures at runtime, but there is no way to call a function with\nautomatically resolved arguments without either code generation or unsafe tricks.\n\nThe closest Go equivalent is [google/wire](https://github.com/google/wire),\nwhich generates wiring code at compile time. This framework takes the explicit\nfactory approach (like Pimple, PHP-DI in manual mode), which is:\n\n- ✅ Transparent — no magic\n- ✅ Type-safe — generics catch mistakes at compile time  \n- ✅ Fast — no reflection at resolve time\n- ✅ Testable — swap any factory in tests with `c.Instance(\"db\", mockDB)`\n"
        }
    ]
}