{
    "sourceFile": "framework/container/provider_test.go",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1772228366258,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1772228366258,
            "name": "Commit-0",
            "content": "package container_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/km-arc/go-laravel/framework/container\"\n)\n\n// ── stub providers ────────────────────────────────────────────────────────────\n\ntype eagerProvider struct {\n\tcontainer.BaseProvider\n\tregisterCalled bool\n\tbootCalled     bool\n}\n\nfunc (p *eagerProvider) Register(app *container.Container) {\n\tp.registerCalled = true\n\tapp.Singleton(\"eager-svc\", func(c *container.Container) any { return \"eager\" })\n}\n\nfunc (p *eagerProvider) Boot(app *container.Container) {\n\tp.bootCalled = true\n}\n\n// deferredProvider is lazy — only registered when \"deferred-svc\" is first resolved.\ntype deferredProvider struct {\n\tcontainer.BaseProvider\n\tregisterCalled bool\n\tbootCalled     bool\n}\n\nfunc (p *deferredProvider) Register(app *container.Container) {\n\tp.registerCalled = true\n\tapp.Singleton(\"deferred-svc\", func(c *container.Container) any { return \"deferred-value\" })\n}\n\nfunc (p *deferredProvider) Boot(app *container.Container) {\n\tp.bootCalled = true\n}\n\nfunc (p *deferredProvider) IsDeferred() bool   { return true }\nfunc (p *deferredProvider) Provides() []string { return []string{\"deferred-svc\"} }\n\n// multiProvider registers multiple abstracts.\ntype multiProvider struct {\n\tcontainer.BaseProvider\n}\n\nfunc (p *multiProvider) Register(app *container.Container) {\n\tapp.Singleton(\"alpha\", func(c *container.Container) any { return \"α\" })\n\tapp.Singleton(\"beta\", func(c *container.Container) any { return \"β\" })\n}\n\n// ── ProviderRegistry ──────────────────────────────────────────────────────────\n\nfunc TestRegistry_EagerProvider_RegisterCalled(t *testing.T) {\n\tc := container.New()\n\treg := container.NewProviderRegistry(c)\n\n\tp := &eagerProvider{}\n\treg.Register(p)\n\n\tif !p.registerCalled {\n\t\tt.Error(\"Register() should be called immediately for eager providers\")\n\t}\n}\n\nfunc TestRegistry_EagerProvider_BootCalledAfterBoot(t *testing.T) {\n\tc := container.New()\n\treg := container.NewProviderRegistry(c)\n\n\tp := &eagerProvider{}\n\treg.Register(p)\n\n\tif p.bootCalled {\n\t\tt.Error(\"Boot() should NOT be called before registry.Boot()\")\n\t}\n\n\treg.Boot()\n\n\tif !p.bootCalled {\n\t\tt.Error(\"Boot() should be called after registry.Boot()\")\n\t}\n}\n\nfunc TestRegistry_EagerProvider_ServiceResolvable(t *testing.T) {\n\tc := container.New()\n\treg := container.NewProviderRegistry(c)\n\treg.Register(&eagerProvider{})\n\treg.Boot()\n\n\tgot := c.Make(\"eager-svc\").(string)\n\tif got != \"eager\" {\n\t\tt.Errorf(\"eager-svc: got %q, want 'eager'\", got)\n\t}\n}\n\nfunc TestRegistry_Boot_IdempotentCallsAreIgnored(t *testing.T) {\n\tc := container.New()\n\treg := container.NewProviderRegistry(c)\n\n\tp := &eagerProvider{}\n\treg.Register(p)\n\n\treg.Boot()\n\treg.Boot() // second call should be no-op\n\n\tif !reg.Booted() {\n\t\tt.Error(\"Booted() should be true after Boot()\")\n\t}\n}\n\nfunc TestRegistry_Booted_FalseBeforeBoot(t *testing.T) {\n\tc := container.New()\n\treg := container.NewProviderRegistry(c)\n\tif reg.Booted() {\n\t\tt.Error(\"Booted() should be false before Boot()\")\n\t}\n}\n\nfunc TestRegistry_DuplicateRegister_Ignored(t *testing.T) {\n\tc := container.New()\n\treg := container.NewProviderRegistry(c)\n\n\tp := &eagerProvider{}\n\treg.Register(p)\n\treg.Register(p) // second register of same instance\n\n\t// registerCalled should still only reflect one real registration\n\tif !p.registerCalled {\n\t\tt.Error(\"provider should have been registered once\")\n\t}\n}\n\n// ── Deferred providers ────────────────────────────────────────────────────────\n\nfunc TestRegistry_DeferredProvider_NotRegisteredEagerly(t *testing.T) {\n\tc := container.New()\n\treg := container.NewProviderRegistry(c)\n\n\tp := &deferredProvider{}\n\treg.Register(p)\n\treg.Boot()\n\n\t// Provider.Register should NOT have been called yet\n\tif p.registerCalled {\n\t\tt.Error(\"deferred provider Register() should not be called until Make()\")\n\t}\n}\n\nfunc TestRegistry_DeferredProvider_RegisteredOnFirstMake(t *testing.T) {\n\tc := container.New()\n\treg := container.NewProviderRegistry(c)\n\n\tp := &deferredProvider{}\n\treg.Register(p)\n\treg.Boot()\n\n\t// Trigger lazy load\n\tgot := c.Make(\"deferred-svc\").(string)\n\tif got != \"deferred-value\" {\n\t\tt.Errorf(\"deferred-svc: got %q, want 'deferred-value'\", got)\n\t}\n}\n\n// ── Multiple providers ────────────────────────────────────────────────────────\n\nfunc TestRegistry_MultipleProviders_AllServicesResolvable(t *testing.T) {\n\tc := container.New()\n\treg := container.NewProviderRegistry(c)\n\treg.Register(&multiProvider{})\n\treg.Register(&eagerProvider{})\n\treg.Boot()\n\n\tif got := c.Make(\"alpha\").(string); got != \"α\" {\n\t\tt.Errorf(\"alpha: got %q, want 'α'\", got)\n\t}\n\tif got := c.Make(\"beta\").(string); got != \"β\" {\n\t\tt.Errorf(\"beta: got %q, want 'β'\", got)\n\t}\n\tif got := c.Make(\"eager-svc\").(string); got != \"eager\" {\n\t\tt.Errorf(\"eager-svc: got %q, want 'eager'\", got)\n\t}\n}\n\n// ── Providers list ────────────────────────────────────────────────────────────\n\nfunc TestRegistry_Providers_ReturnsEagerOnes(t *testing.T) {\n\tc := container.New()\n\treg := container.NewProviderRegistry(c)\n\treg.Register(&eagerProvider{})\n\treg.Register(&deferredProvider{}) // deferred — not in Providers()\n\n\tif len(reg.Providers()) != 1 {\n\t\tt.Errorf(\"Providers(): got %d, want 1 (eager only)\", len(reg.Providers()))\n\t}\n}\n\n// ── BaseProvider defaults ─────────────────────────────────────────────────────\n\nfunc TestBaseProvider_Defaults(t *testing.T) {\n\tvar p container.BaseProvider\n\tc := container.New()\n\n\tp.Boot(c) // should not panic\n\n\tif p.IsDeferred() {\n\t\tt.Error(\"BaseProvider.IsDeferred() should be false\")\n\t}\n\tif len(p.Provides()) != 0 {\n\t\tt.Error(\"BaseProvider.Provides() should return empty slice\")\n\t}\n}\n\n// ── Boot after registration (late provider) ───────────────────────────────────\n\nfunc TestRegistry_RegisterAfterBoot_BootsImmediately(t *testing.T) {\n\tc := container.New()\n\treg := container.NewProviderRegistry(c)\n\treg.Boot() // boot before registering\n\n\tp := &eagerProvider{}\n\treg.Register(p) // register after boot\n\n\tif !p.bootCalled {\n\t\tt.Error(\"provider registered after Boot() should be booted immediately\")\n\t}\n}\n"
        }
    ]
}